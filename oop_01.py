# ООП - 1



# Основные понятия ООП
# Класс - это шаблон для создания объектов. Он определяет структуру и поведение будущих объектов.
class Person:
    pass  # pass указывает на то, что класс пока пустой, без атрибутов и методов

# Объект - это экземпляр класса, который создается с использованием класса.
person1 = Person()  # Создаем первый экземпляр класса Person, представляющий конкретного человека
person2 = Person()  # Создаем второй экземпляр класса Person




# Создание классов и объектов
class Dog:
    # Метод __init__() - это конструктор, который автоматически вызывается при создании нового объекта
    def __init__(self, name, age):
        self.name = name  # Атрибут name экземпляра класса, хранящий имя собаки
        self.age = age  # Атрибут age экземпляра класса, хранящий возраст собаки

    # Метод bark() - это метод экземпляра класса, который определяет поведение собаки
    def bark(self):
        print(f"{self.name} говорит: Гав-гав!")  # Метод выводит сообщение с именем собаки

# Создание объектов класса Dog с различными значениями атрибутов
dog1 = Dog("Барон", 3)  # Создаем первый объект dog1 с именем "Барон" и возрастом 3 года
dog2 = Dog("Рекс", 5)  # Создаем второй объект dog2 с именем "Рекс" и возрастом 5 лет

# Вызов метода bark() для каждого из объектов
dog1.bark()  # Вывод: Барон говорит: Гав-гав!
dog2.bark()  # Вывод: Рекс говорит: Гав-гав!




# Атрибуты и методы класса
class Car:
    wheels = 4  # Атрибут класса, который общий для всех экземпляров класса Car

    def __init__(self, color):
        self.color = color  # Атрибут color экземпляра класса, хранящий цвет автомобиля

    def describe(self):
        # Метод describe() выводит количество колес и цвет автомобиля
        print(f"Этот автомобиль имеет {self.wheels} колеса и цвет {self.color}")

# Создание объектов класса Car с различными цветами
car1 = Car("красный")  # Создаем первый объект car1 с цветом "красный"
car2 = Car("синий")  # Создаем второй объект car2 с цветом "синий"

# Вызов метода describe() для каждого из объектов
car1.describe()  # Вывод: Этот автомобиль имеет 4 колеса и цвет красный
car2.describe()  # Вывод: Этот автомобиль имеет 4 колеса и цвет синий

# Доступ к атрибуту класса wheels
print(Car.wheels)  # Вывод: 4, доступ к атрибуту класса через имя класса
print(car1.wheels)  # Вывод: 4, доступ к атрибуту класса через экземпляр




# Наследование и полиморфизм
# Базовый класс Animal, содержащий метод speak, который будет переопределен в подклассах
class Animal:
    def speak(self):
        pass  # Базовый метод, который будет переопределен в наследниках

# Подкласс Cat, наследующийся от Animal, и переопределяющий метод speak
class Cat(Animal):
    def speak(self):
        print("Мяу")  # Реализация метода speak для класса Cat

# Подкласс Dog, наследующийся от Animal, и переопределяющий метод speak
class Dog(Animal):
    def speak(self):
        print("Гав-гав")  # Реализация метода speak для класса Dog

# Функция, принимающая объект животного и вызывающая его метод speak
def make_animal_speak(animal):
    animal.speak()  # Вызываем метод speak у переданного объекта

# Создание объектов классов Cat и Dog
cat = Cat()  # Создаем объект класса Cat
dog = Dog()  # Создаем объект класса Dog

# Вызов функции make_animal_speak для объектов cat и dog
make_animal_speak(cat)  # Вывод: Мяу
make_animal_speak(dog)  # Вывод: Гав-гав




# Инкапсуляция и защищенные члены
# Класс Person с защищенными и приватными атрибутами
class Person:
    def __init__(self, name, age):
        self._name = name  # Защищенный атрибут, используемый внутри класса и подклассов (Это скорее соглашение, чем жесткое правило)
        self.__age = age  # Приватный атрибут, используемый только внутри класса (Это механизм name mangling, который изменяет имя атрибута таким образом, чтобы затруднить доступ к нему извне класса)

    # Этот декоратор используется для создания свойства, которое позволяет вам обращаться к методу как к атрибуту. То есть, когда вы пишете person.age, фактически вызывается метод age(), но синтаксис выглядит так, как будто вы обращаетесь к атрибуту.
    @property
    def age(self):
        return self.__age  # Геттер для приватного атрибута, возвращает значение возраста

    # Декоратор @age.setter используется для определения метода-сеттера для свойства, созданного с помощью декоратора @property. Он позволяет установить новое значение для свойства, а также выполнить дополнительную логику при установке этого значения (например, проверку валидности).
    @age.setter 
    def age(self, age):
        # Сеттер для приватного атрибута, устанавливает значение возраста, если оно положительное
        if age > 0:
            self.__age = age
        else:
            raise ValueError("Возраст должен быть положительным")  # Генерируем исключение при неправильном значении

# Создание объекта класса Person
person = Person("Иван", 30)  # Создаем объект person с именем "Иван" и возрастом 30 лет
print(person.age)  # Вывод: 30, доступ к значению возраста через геттер
person.age = 31  # Устанавливаем новое значение возраста через сеттер
print(person.age)  # Вывод: 31, проверяем новое значение возраста

# print(person.__age) # выдает ошибку
# print(person._name) # выдает "Иван", но так рекомендовано делать